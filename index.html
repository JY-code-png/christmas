<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display:block; pointer-events: none; }
        h1 { font-weight: 100; letter-spacing: 5px; text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
        #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 999; cursor: pointer; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; border: 1px solid #fff;}
    </style>
</head>
<body>

    <!-- ç‚¹å‡»æ’­æ”¾é®ç½©å±‚ -->
    <div id="overlay">
        <h1>ğŸ„ Merry Christmas ğŸ„</h1>
        <p>ç‚¹å‡»å±å¹•å¼€å§‹ / Click to Start</p>
    </div>

    <!-- ä½ çš„éŸ³ä¹æ–‡ä»¶ (ç¡®ä¿ä½ çš„ä»“åº“é‡Œæœ‰ bgm.mp3) -->
    <audio id="bgm" src="./bgm.mp3" loop></audio>

    <!-- å¼•å…¥ Three.js å¼•æ“ (æ— éœ€ä¸‹è½½ï¼Œç›´æ¥ç”¨) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥è½¨é“æ§åˆ¶å™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- æ ¸å¿ƒé€»è¾‘ ---
        let scene, camera, renderer, controls, material;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        init();
        animate();

        function init() {
            // 1. åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            // å¢åŠ ä¸€ç‚¹è¿·é›¾æ•ˆæœï¼Œæ›´æœ‰æ°›å›´
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);

            // 2. åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 2, 2000);
            camera.position.z = 1000;
            camera.position.y = 200;

            // 3. åˆ›å»ºç²’å­æè´¨ (ç”¨ Canvas ç”»ä¸€ä¸ªå‘å…‰çš„åœ†ç‚¹)
            const spriteMap = new THREE.CanvasTexture(generateSprite());
            
            // å®šä¹‰å‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            // --- ç”Ÿæˆåœ£è¯æ ‘å½¢çŠ¶çš„ç²’å­ ---
            const count = 3000; // ç²’å­æ•°é‡

            for (let i = 0; i < count; i++) {
                // èºæ—‹ä¸Šå‡ç®—æ³•
                const x = Math.random() * 2 - 1;
                const y = Math.random() * 2 - 1;
                const z = Math.random() * 2 - 1;

                // ç®€å•çš„åœ†é”¥ä½“é€»è¾‘
                // é«˜åº¦èŒƒå›´ -500 åˆ° 500
                const height = (Math.random() * 1000) - 500; 
                // åŠå¾„éšé«˜åº¦å˜åŒ–ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„
                const radius = (500 - height) * 0.4 * Math.random();
                
                // è§’åº¦
                const angle = Math.random() * Math.PI * 2;

                const pX = Math.cos(angle) * radius;
                const pY = height;
                const pZ = Math.sin(angle) * radius;

                vertices.push(pX, pY, pZ);

                // é¢œè‰²ï¼šåŸºäºé«˜åº¦åšæ¸å˜ (ç»¿è‰²ä¸ºä¸»ï¼Œå¸¦ç‚¹çº¢é»„)
                const color = new THREE.Color();
                if (Math.random() > 0.9) {
                     color.setHex(0xff0000); // 10% æ¦‚ç‡æ˜¯çº¢çƒ
                } else if (Math.random() > 0.9) {
                     color.setHex(0xffff00); // 10% æ¦‚ç‡æ˜¯é»„çƒ
                } else {
                     // ç»¿è‰²æ¸å˜
                     color.setHSL(Math.random() * 0.1 + 0.25, 0.8, 0.5); 
                }
                
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // ç²’å­æè´¨é…ç½®
            material = new THREE.PointsMaterial({
                size: 15,
                map: spriteMap,
                vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 4. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 5. æ§åˆ¶å™¨ (å…è®¸é¼ æ ‡æ‹–æ‹½)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true; // è‡ªåŠ¨æ—‹è½¬
            controls.autoRotateSpeed = 2.0;

            // äº¤äº’ï¼šç‚¹å‡»å±å¹•æ’­æ”¾éŸ³ä¹å¹¶ç§»é™¤é®ç½©
            document.getElementById('overlay').addEventListener('click', function() {
                const bgm = document.getElementById('bgm');
                bgm.play().then(() => {
                    this.style.opacity = '0';
                    setTimeout(() => this.style.display = 'none', 1000);
                }).catch(e => console.log("è¯·å…ˆäº¤äº’"));
            });

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);
        }

        // ç”Ÿæˆå‘å…‰ç²’å­è´´å›¾
        function generateSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(64,64,64,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return canvas;
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            // ç²’å­é—ªçƒæ•ˆæœ
            const time = Date.now() * 0.00005;
            // scene.rotation.y = time * 2; // æ•´ä½“æ—‹è½¬äº¤ç»™ Controls å¤„ç†
            
            controls.update(); // æ›´æ–°æ§åˆ¶å™¨çŠ¶æ€
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
